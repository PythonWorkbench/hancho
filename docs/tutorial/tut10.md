# Tutorial Chapter 1 - Cooked Hancho, or how to use ```{templates}``` to make generic build tasks.

If you're reading this, you probably decided not to write your own Python scripts and functions to run your build. This tutorial will go into how to use Hancho's text templating system to do the same thing as the helper functions in the previous chapter, but without the functions.

----------
## ```tut10.hancho```: Factoring out the build directory

Let's take a look at the tasks in ```tut02.hancho``` again:

https://github.com/aappleby/hancho/blob/29ee9c997102fe3c361b9a3a7249cfa43ca1693d/tutorial/tut02.hancho#L12-L33

We have to specify the build directory ```build/tut02``` _ten_ times. Let's move it into the config object:

https://github.com/aappleby/hancho/blob/29ee9c997102fe3c361b9a3a7249cfa43ca1693d/tutorial/tut10.hancho#L5-L11

Now we can use it in our tasks along with the other ```config``` fields to un-hardcode our compile task:

https://github.com/aappleby/hancho/blob/29ee9c997102fe3c361b9a3a7249cfa43ca1693d/tutorial/tut10.hancho#L13-L19

And the link task works the same way:

https://github.com/aappleby/hancho/blob/29ee9c997102fe3c361b9a3a7249cfa43ca1693d/tutorial/tut10.hancho#L29-L34

Note that these strings are _not_ Python f-strings since they don't have the
```f""``` prefix. They are now Hancho template strings, which are similar to f-strings except they're not
evaluated immediately. They do have some drawbacks, however:

- Hancho templates can _only_ refer to fields in a ```Config``` object.
  - If you want to use ```print()``` in a template, you have to pass it in via ```Config(print = print)```.
- List comprehensions usually won't work right unless the left-hand side is strictly of the form ```[x for x in...```.
  - TL;DR: Python3 wraps list comprehensions in a scope that prevents additional ```Config``` field references and template expansions in the ```[x for x in...``` part.
  - This is a limitation deep inside the Python3 interpreter that has no good workaround.

And some plus sides that f-strings don't have:
- Templates aren't evaluated until immediately before a task runs, which allows them to include expressions that we may not know the value of beforehand
  - For example, the name of a temporary file generated by another task.
- Hancho templates that refer to ```list```s will get flattened out and joined with spaces
  - Expanding ```"{foo}"``` with ```foo = ["Hello", "Hancho", "World"]``` will produce ```"Hello Hancho World"```
  - Expanding ```"{foo}"``` with ```foo = [[["nesting"]], ["levels"], "don't", [[[[[["matter"]]]]]]]``` will produce ```"nesting levels don't matter"```
- Hancho templates that refer to ```Task```s will be replaced with that task's ```build_files``` converted to absolute paths.
  - In the link task, ```source_files = [main_o, util_o]``` becomes ```["/home/user/hancho/tutorial/build/tut10/src/main.o", "/home/user/hancho/tutorial/build/tut10/src/util.o"]```
- Templates can refer to other templates
  - ```command``` contains ```{build_files}```, ```build_files``` contains ```{build_dir}```, and this all works fine.
- You can nest templates up to ```MAX_EXPAND_DEPTH = 20``` levels deep
  - Probably don't make your templates that complicated, though.
  - Infinite loops like ```Task(command = "lol {command}")``` will expand to ```"lol lol lol lol lol....``` and eventually fail.

----------
## ```tut11.hancho```: Splitting off descriptions and commands.

The ```description``` and ```command``` fields of our compile tasks are now identical. Much like we pulled common fields off tasks and into a ```Config``` object, we can do the same thing a second time to isolate them:

https://github.com/aappleby/hancho/blob/b895dd1792e4bcaa47c670fc0c139278e77a1b4f/tutorial/tut11.hancho#L13-L16

# FIXME this is all wrong

Extending config objects works like prototypal inheritance in Javascript - if you refer to ```config.foo``` and ```config``` doesn't have its own ```foo```, it'll look for ```foo``` in the parent object and so on - up until it hits ```app.global config```, which we haven't talked about yet.

That removes another two lines of task-independent stuff from our compile task:

https://github.com/aappleby/hancho/blob/b895dd1792e4bcaa47c670fc0c139278e77a1b4f/tutorial/tut11.hancho#L18-L22

and our link task is similarly small:

https://github.com/aappleby/hancho/blob/b895dd1792e4bcaa47c670fc0c139278e77a1b4f/tutorial/tut11.hancho#L35-L38

----------
## ```tut12.hancho```: Using builtin functions to factor out ```build_files``` and ```build_deps```

The ```build_files``` and ```build_deps``` in our ```main_o``` and ```util_o``` tasks are almost but not quite identical. We can factor them out, but we'll need to use some of Hancho's built-in functions to do so.

https://github.com/aappleby/hancho/blob/ebb3bec0091cb3fcde2033d933e1722d39fc4672/tutorial/tut12.hancho#L16-L17

To make ```build/tut11/src/main.o``` out of ```build/tut11``` and ```src/main.cpp```, we use ```swap_ext``` to change the file extension to ```.o``` and then join it with ```build_dir```. Easy.

Like most of the Hancho helper functions, ```swap_ext``` and ```join_path``` work on both strings and lists.

The ```join_path``` method can also take as many path pieces as you need to stitch together, and will produce all possible permutations of those pieces. So ```join_path("build", ["debug", "release"], ["foo.o", "bar.o"])``` will produce ```["build/debug/foo.o", "build/debug/bar.o", "build/release/foo.o", "build/release/bar.o"]```.

With that change, our compile tasks are almost one-liners:

https://github.com/aappleby/hancho/blob/ebb3bec0091cb3fcde2033d933e1722d39fc4672/tutorial/tut12.hancho#L20-L26

----------
## ```tut13.hancho```: A bit of syntactical sugar.

We can reduce our tasks to actual one-liners by taking advantage of a little bit of shorthand. Build rules in some build systems like Bazel look like function calls - see ```cc_binary()``` [here](https://bazel.build/reference/be/c-cpp#cc_binary) if you're interested.

Hancho can emulate that as well - just use ```compile = config.rule(...)``` and you can call ```main_o = compile(...)``` directly instead of using ```compile.task(...)```.

First we switch our compile and link configurations over to rules:

https://github.com/aappleby/hancho/blob/ebb3bec0091cb3fcde2033d933e1722d39fc4672/tutorial/tut13.hancho#L13-L23

And then we call those rules. Using ```source_files=``` and ```build_files=``` is optional in rule calls, so our tasks shrink down to this:

https://github.com/aappleby/hancho/blob/ebb3bec0091cb3fcde2033d933e1722d39fc4672/tutorial/tut13.hancho#L25-L27

----------
## ```tut14.hancho```: Absolute vs. relative paths and builtin macros.

Let's go back to the command line for a moment and rebuild ```tut13.hancho```:

```console
user@host:~/hancho/tutorial$ rm -rf build && hancho tut13.hancho -v
[1/3] Compile src/main.cpp
Reason: Rebuilding because /home/user/hancho/tutorial/build/tut13/src/main.o is missing
.$ g++ -MMD -c src/main.cpp -o build/tut13/src/main.o
[2/3] Compile src/util.cpp
Reason: Rebuilding because /home/user/hancho/tutorial/build/tut13/src/util.o is missing
.$ g++ -MMD -c src/util.cpp -o build/tut13/src/util.o
[3/3] Link /home/user/hancho/tutorial/build/tut13/src/main.o /home/user/hancho/tutorial/build/tut13/src/util.o into build/tut13/app
Reason: Rebuilding because /home/user/hancho/tutorial/build/tut13/app is missing
.$ g++ /home/user/hancho/tutorial/build/tut13/src/main.o /home/user/hancho/tutorial/build/tut13/src/util.o -o build/tut13/app
hancho: BUILD PASSED
user@host:~/hancho/tutorial$
```

It works fine, but having absolute paths like ```/home/user/hancho/tutorial/build/tut13/src/main.o``` is a bit annoying. If this were a larger project with deeper directory trees, the absolute paths could make reading our build log awkward.

Like the builtin functions ```joinpath``` and ```swap_ext```, Hancho includes some builtin macros (just named templates without surrounding text) that you can use in your templates.

In particular, ```rel_source_files``` will give us our ```source_files``` field with all the filenames changed to be relative to ```command_path```, the directory where our command is running.

The ```rel_source_files``` macro is defined as ```"{relpath(abs_source_files, command_path)}"```, and ```abs_source_files``` is defined as ```"{joinpath(source_path, source_files)}"```. The macro joins the absolute ```source_path``` with our filenames, then removes the ```command_path``` prefix if present. If ```command_path``` _isn't_ present (say we're pulling in the files from some remote directory), the ```relpath``` will do nothing and we'll still have absolute filenames.

Note that ```abspath``` and ```relpath``` are not necessarily identical to Python's ```os.path.abspath``` or ```Path.relative_to()``` - they need to operate on arrays of filenames, and we need to be slightly more careful about how we add and remove path pieces when symlinks are involved (you may not be using symlinks in your repos, but I find them helpful).

Changing ```source_files``` to ```rel_source_files``` is trivial:

https://github.com/aappleby/hancho/blob/2986d94f0c48f089771c454fdf8111eb22f50291/tutorial/tut14.hancho#L13-L23

and now we see relative paths passed to GCC instead of absolute ones:

```console
user@host:~/hancho/tutorial$ rm -rf build && hancho tut14.hancho -v
[1/3] Compile src/main.cpp
Reason: Rebuilding because /home/user/hancho/tutorial/build/tut14/src/main.o is missing
.$ g++ -MMD -c src/main.cpp -o build/tut14/src/main.o
[2/3] Compile src/util.cpp
Reason: Rebuilding because /home/user/hancho/tutorial/build/tut14/src/util.o is missing
.$ g++ -MMD -c src/util.cpp -o build/tut14/src/util.o
[3/3] Link build/tut14/src/main.o build/tut14/src/util.o into build/tut14/app
Reason: Rebuilding because /home/user/hancho/tutorial/build/tut14/app is missing
.$ g++ build/tut14/src/main.o build/tut14/src/util.o -o build/tut14/app
hancho: BUILD PASSED
user@host:~/hancho/tutorial$
```

----------
## ```tut15.hancho```: Relative paths, now for build files.

We can do the same swap with ```build_files``` -> ```rel_build_files``` and things will still work. While we're at it, let's get rid of ```build_dir``` and just make it part of ```build_path```.

We move ```"build/tut15"``` up a line:

https://github.com/aappleby/hancho/blob/2986d94f0c48f089771c454fdf8111eb22f50291/tutorial/tut15.hancho#L5-L10

and now we can remove ```joinpath(build_dir, ...``` since it' now part of the build path:

https://github.com/aappleby/hancho/blob/2986d94f0c48f089771c454fdf8111eb22f50291/tutorial/tut15.hancho#L12-L26

This is about as far as we can go with templates for now - our build rules are now completely generic, and our tasks are all one-liners.

----------
## ```tut16.hancho```: ```build_config``` and sensible defaults.

There are still a few lines we can remove from our build script by making use of some sensible default values that Hancho provides in a global config object called ```build_config```.

Hancho creates a separate module-wide ```build_config``` object for each .hancho file it loads, and it contains default values for ```command_path```, ```source_path```, and ```build_path``` that will work for most projects. Or at least most of my projects, anyway - I wrote this thing for personal use, so the defaults are the defaults I wanted. Change them if you like. :D

The ```build_path``` default is particularly interesting:

https://github.com/aappleby/hancho/blob/2986d94f0c48f089771c454fdf8111eb22f50291/hancho.py#L720

Unpacking this a bit:
- ```start_path``` is globally defined as the path to the directory you ran ```python3 hancho.py``` in.
- ```build_dir``` is globally defined to be ```"build"``` by default, as doing out-of-tree builds is generally preferred over in-tree builds.
- ```build_tag``` is globally defined to be an empty string, but it can be set to whatever you want. For example, you might want to split your build directory up into separate ```debug``` and ```release``` trees using ```build_tag```.
- ```rel_source_path``` is the same macro as we saw earlier - the source filenames, relative to ```command_path```.

If we set ```build_config.build_tag``` to ```"tut16"``` and then use ```build_config``` in place of ```config```, we can ditch our ```config = Config(...``` object entirely. That in turn means we don't have to ```from hancho import Config``` or ```from pathlib import Path``` anymore either.

Here's the build file in its final form, for now:

https://github.com/aappleby/hancho/blob/2986d94f0c48f089771c454fdf8111eb22f50291/tutorial/tut16.hancho#L1-L19

That's not too shabby. There are more things we can do with ```build_config``` and it would be nice to move our two build rules to a separate ```rules.hancho``` file, but those are topics for Hancho Tutorial Chapter 2 (coming soon).
