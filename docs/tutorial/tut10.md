# Tutorial Chapter 1 - Cooked Hancho, or how to use ```{templates}``` to make generic build tasks.

If you're reading this, you probably decided not to write your own Python scripts and functions to run your build. This tutorial will go into how to use Hancho's text templating system to do the same thing as the helper functions in the previous chapter, but without the functions.

----------
## ```tut10.hancho```: Factoring out the build directory

Let's take a look at the tasks in ```tut02.hancho``` again:

https://github.com/aappleby/hancho/blob/29ee9c997102fe3c361b9a3a7249cfa43ca1693d/tutorial/tut02.hancho#L12-L33

We have to specify the build directory ```build/tut02``` _ten_ times. Let's move it into the config object:

https://github.com/aappleby/hancho/blob/29ee9c997102fe3c361b9a3a7249cfa43ca1693d/tutorial/tut10.hancho#L5-L11

Now we can use it in our tasks along with the other ```config``` fields to un-hardcode our compile task:

https://github.com/aappleby/hancho/blob/29ee9c997102fe3c361b9a3a7249cfa43ca1693d/tutorial/tut10.hancho#L13-L19

And the link task works the same way:

https://github.com/aappleby/hancho/blob/29ee9c997102fe3c361b9a3a7249cfa43ca1693d/tutorial/tut10.hancho#L29-L34

Note that these strings are _not_ Python f-strings since they don't have the
```f""``` prefix. They are now Hancho template strings, which are similar to f-strings except they're not
evaluated immediately. They do have some drawbacks, however:

- Hancho templates can _only_ refer to fields in a ```Config``` object.
  - If you want to use ```print()``` in a template, you have to pass it in via ```Config(print = print)```.
- List comprehensions usually won't work right unless the left-hand side is strictly of the form ```[x for x in...``` 
  - TL;DR: Python3 wraps list comprehensions in a scope that prevents additional ```Config``` field references and template expansions in the ```[x for x in...``` part.
  - This is a limitation deep inside the Python3 interpreter that has no good workaround.

And some plus sides that f-strings don't have:
- Templates aren't evaluated until immediately before a task runs, which allows them to include expressions that we may not know the value of beforehand
  - For example, the name of a temporary file generated by another task. 
- Hancho templates that refer to ```list```s will get flattened out and joined with spaces
  - Expanding ```"{foo}"``` with ```foo = ["Hello", "Hancho", "World"]``` will produce ```"Hello Hancho World"```
  - Expanding ```"{foo}"``` with ```foo = [[["nesting"]], ["levels"], "don't", [[[[[["matter"]]]]]]]``` will produce ```"nesting levels don't matter"```
- Hancho templates that refer to ```Task```s will be replaced with that task's ```build_files``` converted to absolute paths.
  - In the link task, ```source_files = [main_o, util_o]``` becomes ```["/home/user/hancho/tutorial/build/tut10/src/main.o", "/home/user/hancho/tutorial/build/tut10/src/util.o"]```
- Templates can refer to other templates
  - ```command``` contains ```{build_files}```, ```build_files``` contains ```{build_dir}```, and this all works fine.
- You can nest templates up to ```MAX_EXPAND_DEPTH = 20``` levels deep
  - Probably don't make your templates that complicated, though.
  - Infinite loops like ```Task(command = "lol {command}")``` will expand to ```"lol lol lol lol lol....``` and eventually fail.

----------
## ```tut11.hancho```: Splitting off descriptions and commands.

The ```description``` and ```command``` fields of our compile tasks are now identical. Much like we pulled common fields off tasks and into a ```Config``` object, we can do the same thing a second time to isolate them:

https://github.com/aappleby/hancho/blob/b895dd1792e4bcaa47c670fc0c139278e77a1b4f/tutorial/tut11.hancho#L13-L16

Extending config objects works like prototypal inheritance in Javascript - if you refer to ```config.foo``` and ```config``` doesn't have its own ```foo```, it'll look for ```foo``` in the parent object and so on - up until it hits ```global_config```, which we haven't talked about yet.

That removes another two lines of task-independent stuff from our compile task:

https://github.com/aappleby/hancho/blob/b895dd1792e4bcaa47c670fc0c139278e77a1b4f/tutorial/tut11.hancho#L18-L22

and our link task is similarly small:

https://github.com/aappleby/hancho/blob/b895dd1792e4bcaa47c670fc0c139278e77a1b4f/tutorial/tut11.hancho#L35-L38

----------
## ```tut12.hancho```: Using builtin functions to factor out ```build_files``` and ```build_deps```

The ```build_files``` and ```build_deps``` in our ```main_o``` and ```util_o``` tasks are almost but not quite identical. We can factor them out, but we'll need to use some of Hancho's built-in functions to do so.

https://github.com/aappleby/hancho/blob/ebb3bec0091cb3fcde2033d933e1722d39fc4672/tutorial/tut12.hancho#L16-L17

To make ```build/tut11/src/main.o``` out of ```build/tut11``` and ```src/main.cpp```, we use ```swap_ext``` to change the file extension to ```.o``` and then join it with ```build_dir```. Easy.

Like most of the Hancho helper functions, ```swap_ext``` and ```join_path``` work on both strings and lists.

The ```join_path``` method can also take as many path pieces as you need to stitch together, and will produce all possible permutations of those pieces. So ```join_path("build", ["debug", "release"], ["foo.o", "bar.o"])``` will produce ```["build/debug/foo.o", "build/debug/bar.o", "build/release/foo.o", "build/release/bar.o"]```.

With that change, our compile tasks are almost one-liners:

https://github.com/aappleby/hancho/blob/ebb3bec0091cb3fcde2033d933e1722d39fc4672/tutorial/tut12.hancho#L20-L26

----------
## ```tut13.hancho```: A bit of syntactical sugar.

We can reduce our tasks to actual one-liners by taking advantage of a little bit of shorthand. Build rules in some build systems like Bazel look like function calls - see ```cc_binary()``` [here](https://bazel.build/reference/be/c-cpp#cc_binary) if you're interested.

Hancho can emulate that as well - just use ```compile = config.rule(...)``` and you can call ```main_o = compile(...)``` directly instead of using ```compile.task(...)```.

First we switch our compile and link configurations over to rules:

https://github.com/aappleby/hancho/blob/ebb3bec0091cb3fcde2033d933e1722d39fc4672/tutorial/tut13.hancho#L13-L23

And then we call those rules. Using ```source_files=``` and ```build_files=``` is optional in rule calls, so our tasks shrink down to this:

https://github.com/aappleby/hancho/blob/ebb3bec0091cb3fcde2033d933e1722d39fc4672/tutorial/tut13.hancho#L25-L27
