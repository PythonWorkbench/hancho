# Tutorial Chapter 0 - Raw Hancho

Hancho packs a lot of functionality into a single Python file, but you don't have to use all of it - you can create tasks manually and Hancho will
run them in dependency order while parallelizing the build as much as possible.

In the first chapter of this tutorial, we'll create a single hardcoded Hancho task and refactor it into a more capable build tool without using any additional Hancho features.

## ```tut00.hancho```: Everything in a single task

A Hancho Task object contains nine essential fields - six are mandatory, three are optional.

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut00.hancho#L5-L15

These essential fields are:

| Field  | Required?| Description
|---|---|---|
|desc|No|The description to print on the console when this task starts
|command|Yes|The command you want to run
|command_path |Yes| The _absolute_ path to the directory you want to run the command in
|command_files|No| Files that 'command' needs in order to run, relative to command_path <p>Used to ensure that 'command' reruns when config files or scripts change.
|source_path|Yes|The _absolute_ path to the directory your source code is in
|source_files|Yes|Files you want 'command' to process, relative to 'source_path' <p>These are the upstream links in the Hancho dependency graph.
|build_path|Yes|The _absolute_ path to the directory containing the files generated by 'command'
|build_files|Yes|Files generated by 'command', relative to 'build_path'<p>These are the downstream links in the Hancho dependency graph.
|build_deps|No| Files containing additional dependency information generated by 'command', relative to 'build_path'<p>Tools such as GCC can generate detailed dependency information via the '-MMD' flag, and Hancho can ingest them to get a complete view of what '.h' files are needed by your '.c' files without you having to specify them individually.

Of course, you'd never actually make a build script like this. It doesn't deal with dependencies _at all_ and all the paths are hardcoded. 

## ```tut01.hancho```: Compiling and Linking

Let's fix the dependency issue in ```tut01.hancho```. We can break the single Task up into three pieces - one to compile each source file and one to link the binary.

Compiling ```main.cpp``` is straightforward - we create a task and store it in ```main_o``` so we can use it later:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut01.hancho#L5-L15

We're using ```build_deps``` now, so Hancho will automatically pick up any transitive header dependencies that ```main.cpp``` pulls in. Compiling ```utils.cpp``` works identically.

To link the binary, we pass the ```main_o``` and ```util_o``` tasks into ```source_files``` in place of filenames. Hancho will see that the link rule depends on the compile rules and won't schedule linking until compilation is done.

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut01.hancho#L29-L39

## ```tut02.hancho```: Factoring out common fields

We've got a lot of redundant stuff in ```tut01.hancho``` that we can remove with a bit of refactoring. We'll create a ```Config``` object to hold the common fields:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut02.hancho#L2-L10

A Config object is just a fancy ```dict``` that supports both ```foo['bar']``` and ```foo.bar``` style lookups. We can also spawn ```Task```s off of it that will inherit the ```Config```'s fields:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut02.hancho#L12-L18

Our link task is also a lot smaller now:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut02.hancho#L28-L33

## ```tut03.hancho```: Generating ```Task```s with functions

Hardcoding all our paths is a bad idea. Let's make a compile-task-generating functions using Python's f-string syntax. If you're not familiar with f-strings, they are Python strings prefixed with ```f""``` that can use ```{bracketed expressions}``` to embed Python code inside the string. When the f-string is evaluated, Python will replace the contents of the ```{}```s with the value of the expressions inside them.

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut03.hancho#L12-L21

And a linker function:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut03.hancho#L23-L30

And now the meat of our build is just three lines:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut03.hancho#L32-L34

## ```tut04.hancho```: Pulling our functions out into a separate module

There's one more step we can do to modularize the code - we can cut and paste put our helper functions in their own module ```tut04_rules.py```. To use that, we need to ```import``` the module from the current directory, which requires tweaking ```sys.path```: 

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut04.hancho#L5-L7

Once we've done that, our tasks can use the functions from ```tut04_rules.py```:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut04.hancho#L9-L18

And now our build-agnostic stuff is in ```tut04_rules.py``` and our build-specific stuff is in ```tut04.hancho``` - that's a good start.

# Should we stop here, or continue further?

If you really like writing Python, you can stop reading the tutorials here and get to work on scaling up this tiny example to build your own applications. You'll probably need to handle globbing, multiple build configurations, that sort of thing. It's a bit tedious, but Hancho's task runner should Just Work (tm).

If you'd rather not do that, the next tutorial chapter will go into Hancho's text templating system which combines ```Config``` objects with ```"text {template} powers"``` to produce something more like a declarative build system instead of an imperative build system.
