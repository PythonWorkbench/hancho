# Tutorial Chapter 0 - Raw Hancho

Hancho packs a lot of functionality into a single Python file, but you don't have to use all of it - you can create tasks manually and Hancho will
run them in dependency order while parallelizing the build as much as possible.

In the first chapter of this tutorial, we'll create a single hardcoded Hancho task and refactor it into a more capable build tool without using any additional Hancho features.

A Hancho Task object contains nine essential fields - six are mandatory, three are optional.

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut00.hancho#L5-L15

These essential fields are:

| Field  | Required?| Description
|---|---|---|
|desc|No|The description to print on the console when this task starts
|command|Yes|The command you want to run
|command_path |Yes| The _absolute_ path to the directory you want to run the command in
|command_files|No| Files that 'command' needs in order to run, relative to command_path <p>Used to ensure that 'command' reruns when config files or scripts change.
|source_path|Yes|The _absolute_ path to the directory your source code is in
|source_files|Yes|Files you want 'command' to process, relative to 'source_path' <p>These are the upstream links in the Hancho dependency graph.
|build_path|Yes|The _absolute_ path to the directory containing the files generated by 'command'
|build_files|Yes|Files generated by 'command', relative to 'build_path'<p>These are the downstream links in the Hancho dependency graph.
|build_deps|No| Files containing additional dependency information generated by 'command', relative to 'build_path'<p>Tools such as GCC can generate detailed dependency information via the '-MMD' flag, and Hancho can ingest them to get a complete view of what '.h' files are needed by your '.c' files without you having to specify them individually.

Of course, the example in tut00.hancho doesn't deal with dependencies at all. Let's fix that. We can break the single Task up into three pieces - one to compile each source file and one to link the binary.

Compiling main.cpp is straightforward - we create a task and store it in main_o so we can use it later:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut01.hancho#L5-L15

We're using build_deps now, so Hancho will automatically pick up any transitive header dependencies that main.cpp pulls in. Compiling utils.cpp works identically.

To link the binary, we pass the main_o and util_o tasks into source_files in place of filenames. Hancho will see that the link rule depends on the compile rules and won't schedule linking until compilation is done.

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut01.hancho#L29-L39
