# Tutorial Chapter 0 - Raw Hancho

Hancho packs a lot of functionality into a single Python file, but you don't have to use all of it - you can create tasks manually and Hancho will
run them in dependency order while parallelizing the build as much as possible.

In the first chapter of this tutorial, we'll create a single hardcoded Hancho task and refactor it into a more capable build tool without using any additional Hancho features.

## ```tut00.hancho```: Everything in a single task

A Hancho Task object contains nine essential fields - six are mandatory, three are optional.

| Field  | Required?| Description
|---|---|---|
|desc|No|The description to print on the console when this task starts
|command|Yes|The command you want to run
|command_path |No| The _absolute_ path to the directory you want to run the command in.<p>Defaults to the working directory.
|command_files|No| Files that 'command' needs in order to run, relative to command_path <p>Used to ensure that 'command' reruns when config files or scripts change.
|source_path|No|The _absolute_ path to the directory your source code is in.<p>Defaults to the working directory.
|source_files|Yes|Files you want 'command' to process, relative to 'source_path' <p>These are the upstream links in the Hancho dependency graph.
|build_path|No|The _absolute_ path to the directory containing the files generated by 'command'.<p>Defaults to "build", with some details to be mentioned later.
|build_files|Yes|Files generated by 'command', relative to 'build_path'<p>These are the downstream links in the Hancho dependency graph.
|build_deps|No| Files containing additional dependency information generated by 'command', relative to 'build_path'<p>Tools such as GCC can generate detailed dependency information via the '-MMD' flag, and Hancho can ingest them to get a complete view of what '.h' files are needed by your '.c' files without you having to specify them individually.

Creating a task looks like this:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut00.hancho#L5-L15

If you run ```python3 ../hancho.py tut00.hancho``` in the ```tutorial``` directory, you should see the following:

```console
user@host:~/hancho/tutorial$ python3 ../hancho.py tut00.hancho
[1/1] Compile main.cpp and util.cpp and link app
hancho: BUILD PASSED
user@host:~/hancho/tutorial$
```

And the binary should work:
```console
user@host:~/hancho/tutorial$ build/tut00/app
Hello World 42
```

Of course, you'd never actually make a build script like this. It doesn't deal with dependencies _at all_ and all the paths are hardcoded.

## ```tut01.hancho```: Compiling and Linking

Let's fix the dependency issue first. We can break the single ```Task``` up into three pieces - one to compile each source file and one to link the binary.

Compiling ```main.cpp``` is straightforward - we create a task and store it in ```main_o``` so we can use it later:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut01.hancho#L5-L15

We've added ```-MMD``` to the GCC command line to tell it to generate ```.d``` dependency files, which we can then reference in ```build_deps```. Hancho will use these files to automatically pick up any transitive header dependencies that ```main.cpp``` pulls in. Compiling ```utils.cpp``` works identically.

To link the binary, we pass the ```main_o``` and ```util_o``` tasks into ```source_files``` in place of filenames. Hancho will see that the link rule depends on the compile rules and won't schedule linking until compilation is done.

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut01.hancho#L29-L39

We can see the details of each command run for each build step with the ```-v``` (verbose) option.

```console
user@host:~/hancho/tutorial$ python3 ../hancho.py -v tut01.hancho
[1/3] Compile main.cpp
Reason: Rebuilding because /home/user/hancho/tutorial/build/tut01/src/main.o is missing
.$ g++ -MMD -c src/main.cpp -o build/tut01/src/main.o
[2/3] Compile util.cpp
Reason: Rebuilding because /home/user/hancho/tutorial/build/tut01/src/util.o is missing
.$ g++ -MMD -c src/util.cpp -o build/tut01/src/util.o
[3/3] Link main.o and util.o into app
Reason: Rebuilding because /home/user/hancho/tutorial/build/tut01/app is missing
.$ g++ build/tut01/src/main.o build/tut01/src/util.o -o build/tut01/app
hancho: BUILD PASSED
user@host:~/hancho/tutorial$
```

If we modify ```main.cpp``` and run Hancho again, we should see that only one compile task happens:

```console
user@host:~/hancho/tutorial$ touch src/main.cpp
user@host:~/hancho/tutorial$ python3 ../hancho.py -v tut01.hancho
[1/3] Compile main.cpp
Reason: Rebuilding because /home/user/hancho/tutorial/src/main.cpp has changed
.$ g++ -MMD -c src/main.cpp -o build/tut01/src/main.o
[2/3] Link main.o and util.o into app
Reason: Rebuilding because /home/user/hancho/tutorial/build/tut01/src/main.o has changed
.$ g++ build/tut01/src/main.o build/tut01/src/util.o -o build/tut01/app
hancho: BUILD PASSED
user@host:~/hancho/tutorial$
```

The Hancho output for all the tutorial steps after this one will look basically identical to the above, so we won't bother showing them again.

## ```tut02.hancho```: Factoring out common fields

We've got a lot of redundant stuff in ```tut01.hancho``` that we can remove with a bit of refactoring. We'll create a Hancho ```Config``` object to hold the common fields:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut02.hancho#L2-L10

A Config object is just a fancy ```dict``` that supports both ```foo['bar']``` and ```foo.bar``` style lookups. We can also spawn ```Task```s off of it that will inherit the ```Config```'s fields:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut02.hancho#L12-L18

Our link task is also a lot smaller now:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut02.hancho#L28-L33


FIXME write a section for this -
Different ways to merge Configs together:
```
#   compile = config | Config(...)
#   compile = config.config(...)
#     I don't like this one as it implies that config could be doing something in addition to just the key merge
#   compile = Config(..., **config)
#   compile = Config(config, ...)
#   compile = Config(config), compile.update(...)
#   other = Config(...), compile = Config(config, other)
#   compile = Config(config), compile |= Config(...)
#   compile = config.extend(...)

# main_o = (config | compile)(...)
```




## ```tut03.hancho```: Generating ```Task```s with functions

Hardcoding all our paths is a bad idea. Let's make a compile-task-generating function that uses Python's f-string syntax. If you're not familiar with f-strings, they are Python strings prefixed with ```f""``` that can use ```{bracketed expressions}``` to embed Python code inside the string. When the f-string is evaluated, Python will replace the contents of the ```{}```s with the value of the expressions inside them.

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut03.hancho#L12-L21

And a linker function:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut03.hancho#L23-L30

And now the meat of our build is just three lines:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut03.hancho#L32-L34

## ```tut04.hancho```: Pulling our functions out into a separate module

There's one more step we can do to modularize the code - we can cut and paste put our helper functions in their own module ```tut04_rules.py```.

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut04_rules.py#L1-L19

To use that, we need to ```import``` the module from the current directory, which requires tweaking ```sys.path```:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut04.hancho#L5-L7

Once we've done that, our tasks can use the functions from ```tut04_rules.py```:

https://github.com/aappleby/hancho/blob/76db54866112e3847d17391f6cb27680297d2781/tutorial/tut04.hancho#L16-L18

And now our build-agnostic stuff is in ```tut04_rules.py``` and our build-specific stuff is in ```tut04.hancho``` - that's a good start.

# Should we stop here, or continue further?

If you really like writing Python, you can stop reading the tutorials here and get to work on scaling up this tiny example to build your own applications. You'll probably need to handle globbing, multiple build configurations, that sort of thing. It's a bit tedious, but Hancho's task runner should Just Work (tm).

If you'd rather not do that, the next tutorial chapter will go into Hancho's text templating system which combines ```Config``` objects with ```"text {template} powers"``` to produce something more like a traditional build system instead of just a Python script that creates tasks.
