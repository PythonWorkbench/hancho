### Tutorial 0: Running Hancho

Hancho is distributed as a single Python file with no dependencies, just download it to your working directory:

``` bash
wget https://raw.githubusercontent.com/aappleby/hancho/main/hancho.py
chmod +x hancho.py
./hancho.py
```

Since we're already in the Hancho repo, [tutorial/hancho.py](tutorial/hancho.py) is just symlink'd to the copy in the repo root.

Let's start off by using Hancho to compile a trivial "Hello World" application:

``` cpp
// src/main.cpp
#include <stdio.h>
#include "main.hpp"

int main(int argc, char** argv) {
  printf("Hello World\n");
  return 0;
}
```

Hancho build files are Python modules that contain Hancho build rules and build invocations. Our starting build file just hardcodes a build rule with a description and a command and then runs it.
``` py
# tutorial/tut0.hancho
import hancho

# All rules must have a command, in this case a console command to run the
# compiler. Rules can have an optional description that is printed when they
# run.
rule = hancho.Rule(
  desc      = "Compile src/main.cpp",
  command   = "g++ src/main.cpp -o build/tut0/app",
)

# You run the rule by calling it with a list of input files to run it on and a
# list of output files it should produce. If you only have a single file, you
# can omit the [].
# Note that running a rule _requires_ files_in and files_out - these can be
# empty arrays, but Hancho needs to know what goes into and out of a rule to
# enable dependency checking:
rule(
  files_in  = "src/main.cpp",
  files_out = "build/tut0/app",
)

# That's it, "hancho.py tut0.hancho" will compile build/tut0/app when needed.
```

Let's see if it works. If we run Hancho twice, the first run should compile the app
and the second run should do nothing.

```shell
user@host:~/hancho/tutorial$ ./hancho.py tut0.hancho
[   1] Compile src/main.cpp
user@host:~/hancho/tutorial$ build/tut0/app
Hello World
user@host:~/hancho/tutorial$ ./hancho.py tut0.hancho
hancho: no work to do.
```

Seems to work. To see the commands as they're executed, use the ```--verbose``` flag:

```shell
user@host:~/hancho/tutorial$ rm -rf build
user@host:~/hancho/tutorial$ ./hancho.py tut0.hancho --verbose
[   1] Compile src/main.cpp
g++ src/main.cpp -o build/tut0/app
```

----------
### Tutorial 1: Compiling a C binary

Hardcoded build commands aren't terribly useful. Let's walk through tut1.hancho and see how we can make some reusable rules.

Strings in Hancho rules can contain templates - Python expressions contained in {} brackets. When the rule is evaluated, Hancho will replace the expressions in the templates with their evaluated values.


```py
# tutorial/tut1.hancho
import hancho

# Hancho will expand {} templates before running the command.
rule_compile = hancho.Rule(
  desc = "Compile {files_in} -> {files_out}",
  command = "g++ -c {files_in[0]} -o {files_out[0]}",
)
```

Some expressions have special meanings in Hancho - for example, "files_in" is always the list of files passed into a rule, and "files_out" is always the list of files generated by a rule.

Since templates can contain Python expressions, we can join a list of strings into a single string using ```' '.join(files_in)```

```py
# Templates can contain Python expressions.
rule_link = hancho.Rule(
  desc = "Link {files_in} -> {files_out}",
  command = "g++ {' '.join(files_in)} -o {files_out[0]}",
)
```

When we need to pass the outputs of one rule to the inputs of another rule, we can use the return value from invoking the rule. The return value is a _promise_ for the result of invoking the rule, and can be passed to other rules to chain them together.

```py
# Calling rule_compile() here returns a promise that resolves to a list of
# filenames if it succeeds, or None if it fails.
main_o = rule_compile(
  files_in = "src/main.cpp",
  files_out = "build/tut1/src/main.o",
)

# By passing that promise into rule_link, we create a dependency between the
# link task and the compile task.
rule_link(
  files_in = main_o,
  files_out = "build/tut1/app"
)
```

And let's check the results:

```shell
user@host:~/hancho/tutorial$ ./hancho.py tut1.hancho --verbose
[   1] Compile ['src/main.cpp'] -> ['build/tut1/src/main.o']
g++ -c src/main.cpp -o build/tut1/src/main.o
[   2] Link ['build/tut1/src/main.o'] -> ['build/tut1/app']
g++ build/tut1/src/main.o -o build/tut1/app
user@host:~/hancho/tutorial$ ./hancho.py tut1.hancho --verbose
hancho: no work to do.
user@host:~/hancho/tutorial$ touch src/main.cpp
user@host:~/hancho/tutorial$ ./hancho.py tut1.hancho --verbose
[   1] Compile ['src/main.cpp'] -> ['build/tut1/src/main.o']
g++ -c src/main.cpp -o build/tut1/src/main.o
[   2] Link ['build/tut1/src/main.o'] -> ['build/tut1/app']
g++ build/tut1/src/main.o -o build/tut1/app
```

Dependency checking between the two rules seems to be working - modifying main.cpp causes both the compiler and linker rules to run.


----------
### Tutorial 2: Hancho builtins

In the previous example we hardcoded our output directory ```build/``` and the object filename ```build/src/main.o```. Let's make those more generic.

Hancho contains a small number of built-in functions to make common build tasks easier. These are contained in ```hancho.base_rule``` - a Rule object that we can extend with our own commands. Rule objects work much like Javascript objects, which use 'prototypical' inheritance - each rule can 'inherit' from another rule via Rule.extend(), and inside a template we can use both the parent's and the child's fields. We can also attach functions to rules and call those functions inside template strings.

Hancho's base_rule also defines some special fields such as ```build_dir```, which specifies where Hancho should place output files. The ```depfile``` field tells Hancho where to find a file that contains the list of dependencies for the rule output(s). The dependency file should be in [GCC format](http://find_a_gcc_format_reference). To make GCC generate a depfile when we compile source code, we pass it the ```-MMD``` option.

```py
# tutorial/tut2.hancho
import hancho

# To make all rules in this tutorial use the same build directory, we'll first
# extend Hancho's built-in generic rule and specify build_dir.
base_tut2 = hancho.base_rule.extend(
  build_dir = "build/tut2",
)

# We can then extend that to produce our compile and link rules.
# By using the swap_ext built-in, we can make our files_out and depfile
# parameters generic so we don't have to specify them for each invocation.
rule_compile = base_tut2.extend(
  desc      = "Compile {files_in} -> {files_out}",
  command   = "g++ -MMD -c {files_in[0]} -o {files_out[0]}",
  files_out = "{swap_ext(files_in[0], '.o')}",
  depfile   = "{build_dir}/{swap_ext(files_in[0], '.d')}",
)

# The join() builtin here joins lists of strings with spaces so that lists of
# filenames, for example, can be plugged into a command.
rule_link = base_tut2.extend(
  desc      = "Link {files_in} -> {files_out}",
  command   = "g++ {join(files_in)} -o {files_out[0]}",
)

# Now we don't need files_out here, and we'll also automatically pick up the
# G++ dependency file generated by the -MMD option.
main_o = rule_compile(
  files_in = "src/main.cpp",
)

rule_link(
  files_in = main_o,
  files_out = "app"
)

```

```shell
user@host:~/hancho/tutorial$ ./hancho.py tut2.hancho --verbose
[   1] Compile ['src/main.cpp'] -> ['build/tut2/src/main.o']
g++ -MMD -c src/main.cpp -o build/tut2/src/main.o
[   2] Link ['build/tut2/src/main.o'] -> ['build/tut2/app']
g++ build/tut2/src/main.o -o build/tut2/app
user@host:~/hancho/tutorial$ ./hancho.py tut2.hancho --verbose
hancho: no work to do.
user@host:~/hancho/tutorial$ touch src/main.hpp
user@host:~/hancho/tutorial$ ./hancho.py tut2.hancho --verbose
[   1] Compile ['src/main.cpp'] -> ['build/tut2/src/main.o']
g++ -MMD -c src/main.cpp -o build/tut2/src/main.o
[   2] Link ['build/tut2/src/main.o'] -> ['build/tut2/app']
g++ build/tut2/src/main.o -o build/tut2/app
```

Modifying a header file that's not mentioned in the .hancho file now causes a rebuild thanks to the depfile generated by GCC.

```
user@host:~/hancho/tutorial$ tree build
build
└── tut2
    ├── app
    └── src
        ├── main.d
        └── main.o

2 directories, 3 files
```

And the files are all under ```build/tut2``` as they should be.

-----
### Tutorial 3 - Rule Files, Globs, and Helper Functions

We can move the boilerplate stuff that we'll be using in multiple .hancho files
into its own file for easier reuse.

```py
# tutorial/tut5.hancho - Rule Files, Globs, and Helper Functions
import hancho
import glob

# You can load additional Hancho build files as needed, though be sure to
# await them before using (darn asynchrony...)
rules = await hancho.load("rules.hancho")

# Since c_binary expects a list of filenames, we can use Python's built in
# glob functionality to compile all .cpp files in src/ into a binary.
rules.c_binary("app", glob.glob("src/*.cpp"))
```

Here's the rules file:
```py
import hancho

# We extend base_rule just like the previous example
base_tut6 = hancho.base_rule.extend(
  build_dir = "build/tut6"
)

# And these rules are the same as the previous example
rule_compile = base_tut6.extend(
  desc      = "Compile {files_in} -> {files_out}",
  command   = "g++ -c {files_in[0]} -o {files_out[0]}",
  files_out = "{swap_ext(files_in[0], '.o')}",
  depfile   = "{build_dir}/{swap_ext(files_in[0], '.d')}",
)

rule_link = base_tut6.extend(
  desc      = "Link {files_in} -> {files_out}",
  command   = "g++ {join(files_in)} -o {files_out[0]}",
)

# But since we're in Python, we can make helper functions to call rules for us
def compile(files):
  objs = []
  for file in files:
    objs.append(rule_compile(files_in = file))
  return objs

# And now compiling a bunch of files into a binary is just one call.
def c_binary(name, files):
  rule_link(
    files_in = compile(files),
    files_out = name
  )
```

-----
### Addendum - Debugging Hancho

The ```--debug``` flag will print very verbose internal info about the Hancho rules:

```shell
user@host:~/hancho/tutorial$ ./hancho.py tut0.hancho --debug
expand "None"
expand ""
expand "src/main.cpp"
expand "build/tut0/app"
expand "g++ src/main.cpp -o build/tut0/app"
expand "Compile src/main.cpp"
[   1] Compile src/main.cpp
Rebuild reason: Rebuilding ['/home/user/hancho/tutorial/build/tut0/app'] because some are missing
{
  "files_in" : ["src/main.cpp"],
  "files_out" : ["build/tut0/app"],
  "base" : {
    "desc" : "Compile src/main.cpp",
    "command" : "g++ src/main.cpp -o build/tut0/app",
    "base" : null,
  },
  "meta_deps" : ["/home/user/hancho/tutorial/tut0.hancho"],
  "deps" : [],
  "abs_files_in" : ["/home/user/hancho/tutorial/src/main.cpp"],
  "abs_files_out" : ["/home/user/hancho/tutorial/build/tut0/app"],
  "abs_deps" : [],
}
g++ src/main.cpp -o build/tut0/app
Files ['/home/user/hancho/tutorial/build/tut0/app'] are up to date
```

The components of the debug output are:
 - "expand ..." messages for all text expansions (explained shortly)
 - The description for each rule evaluated
 - The reason the rule was (or was not) executed
 - A JSON representation of the rule object
 - The command executed
