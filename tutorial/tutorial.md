### Tutorial 0: Running Hancho
---

Hancho is distributed as a single Python file with no dependencies, just download it to your working directory:

``` bash
wget https://raw.githubusercontent.com/aappleby/hancho/main/hancho.py
chmod +x hancho.py
./hancho.py
```

Since we're already in the Hancho repo, [tutorial/hancho.py](tutorial/hancho.py) is just symlink'd to the copy in the repo root.

Let's start off by using Hancho to compile a trivial "Hello World" application:

``` cpp
// src/main.cpp
#include <stdio.h>
#include "main.hpp"

int main(int argc, char** argv) {
  printf("Hello World\n");
  return 0;
}
```

Hancho build files are Python modules that contain Hancho build rules and build rule invocations. Here's a trivial .hancho file to compile the above source, with comments:

``` py
# tutorial/tut0.hancho - Running Hancho
import hancho

# Hancho build tasks are described using Rule objects, which are basically
# Python dicts with some tweaks that we'll get into later. Rule objects accept
# whatever key-value pairs you want to pass into the constructor. All rules
# must have a command, in this case a console command to run the compiler.
# Rules can have an optional description that is printed when they run.
rule = hancho.Rule(
  desc    = "Compile src/main.cpp",
  command = "g++ src/main.cpp -o build/tut0/app",
)

# You run the rule by calling it with a list of input files to run it on and a
# list of output files it should produce. If you only have a single file, you
# can omit the [].

# Note that Hancho resolves filenames ***relative to the directory the .hancho
# file is in***, not the directory that Hancho was started in. Hancho will also
# create any directories required by files_out before running the command.

# The files_in and files_out parameters are ***mandatory*** - these can be
# empty arrays, but Hancho needs to know what goes into and out of a rule to
# enable dependency checking.

rule(
  files_in  = "src/main.cpp",
  files_out = "build/tut0/app",
)

# That's it, "hancho.py tut0.hancho" will compile build/tut0/app when needed.
```

Let's see if it works. If we run Hancho twice, the first run should compile the app
and the second run should do nothing.

```shell
user@host:~/hancho/tutorial$ ./hancho.py tut0.hancho
[1/1] Compile src/main.cpp
user@host:~/hancho/tutorial$ build/tut0/app
Hello World
user@host:~/hancho/tutorial$ ./hancho.py tut0.hancho
hancho: no work to do.
```

Seems to work. To see the commands as they're executed, use the ```--verbose``` flag:

```shell
user@host:~/hancho/tutorial$ rm -rf build
user@host:~/hancho/tutorial$ ./hancho.py tut0.hancho --verbose
[1/1] Compile src/main.cpp
Rebuild reason: Rebuilding ['~/hancho/tutorial/build/tut0/app'] because some are missing
g++ src/main.cpp -o build/tut0/app
```

---
### Tutorial 1: Compiling a C binary

Hardcoded build commands aren't terribly useful. Let's walk through tut1.hancho and see how we can make some reusable rules.

Strings in Hancho rules can contain templates - Python expressions contained in {} brackets. When the rule is evaluated, Hancho will replace the expressions in the templates with their evaluated values.


```py
# tutorial/tut1.hancho - Compiling a C Binary
import hancho

# Hancho will expand {} templates before running the command.
rule_compile = hancho.Rule(
  desc = "Compile {files_in} -> {files_out}",
  command = "g++ -c {files_in[0]} -o {files_out[0]}",
)
```

Some expressions have special meanings in Hancho - for example, "files_in" is always the list of files passed into a rule, and "files_out" is always the list of files generated by a rule.

Since templates can contain Python expressions, we can join a list of strings into a single string using ```' '.join(files_in)```

```py
# Templates can contain Python expressions.
rule_link = hancho.Rule(
  desc = "Link {files_in} -> {files_out}",
  command = "g++ {' '.join(files_in)} -o {files_out[0]}",
)
```

When we need to pass the outputs of one rule to the inputs of another rule, we can use the return value from invoking the rule. The return value is a _promise_ for the result of invoking the rule, and can be passed to other rules to chain them together.

```py
# Calling rule_compile() here returns a promise that resolves to a list of
# filenames if it succeeds, or None if it fails.
main_o = rule_compile(
  files_in = "src/main.cpp",
  files_out = "build/tut1/src/main.o",
)

# By passing that promise into rule_link, we create a dependency between the
# link task and the compile task.
rule_link(
  files_in = main_o,
  files_out = "build/tut1/app"
)
```

And let's check the results:

```shell
user@host:~/hancho/tutorial$ ./hancho.py tut1.hancho --verbose
[   1] Compile ['src/main.cpp'] -> ['build/tut1/src/main.o']
g++ -c src/main.cpp -o build/tut1/src/main.o
[   2] Link ['build/tut1/src/main.o'] -> ['build/tut1/app']
g++ build/tut1/src/main.o -o build/tut1/app
user@host:~/hancho/tutorial$ ./hancho.py tut1.hancho --verbose
hancho: no work to do.
user@host:~/hancho/tutorial$ touch src/main.cpp
user@host:~/hancho/tutorial$ ./hancho.py tut1.hancho --verbose
[   1] Compile ['src/main.cpp'] -> ['build/tut1/src/main.o']
g++ -c src/main.cpp -o build/tut1/src/main.o
[   2] Link ['build/tut1/src/main.o'] -> ['build/tut1/app']
g++ build/tut1/src/main.o -o build/tut1/app
```

Dependency checking between the two rules seems to be working - modifying main.cpp causes both the compiler and linker rules to run.

---
### Tutorial 2: Hancho builtins

In the previous example we hardcoded our output directory ```build/``` and the object filename ```build/src/main.o```. Let's make those more generic.

Hancho contains a small number of built-in functions to make common build tasks easier. These are contained in ```hancho.config```, which is also a Rule object. Rule objects work much like Javascript objects, which use 'prototypical' inheritance - each rule can 'inherit' from another rule via Rule.extend(), and inside a template we can use both the parent's and the child's fields. We can also attach functions to rules and call those functions inside template strings.

Hancho's base_rule also defines some special fields such as ```build_dir```, which specifies where Hancho should place output files. The ```depfile``` field tells Hancho where to find a file that contains the list of dependencies for the rule output(s). The dependency file should be in [GCC format](http://www.google.com/search?q=gcc+dependency+file+format). To make GCC generate a depfile when we compile source code, we pass it the ```-MMD``` option.

```py
# tutorial/tut2.hancho - Extending base_rule & calling builtin functions
import hancho

# To make all rules in this tutorial use the same build directory, we'll first
# extend Hancho's built-in generic rule and specify build_dir.
base_tut2 = hancho.Rule(
  build_dir = "build/tut2",
)

# We can then extend that to produce our compile and link rules.
# By using the swap_ext built-in, we can make our files_out and depfile
# parameters generic so we don't have to specify them for each invocation.
rule_compile = base_tut2.extend(
  desc      = "Compile {files_in} -> {files_out}",
  command   = "g++ -MMD -c {files_in[0]} -o {files_out[0]}",
  files_out = "{swap_ext(files_in[0], '.o')}",
  depfile   = "{build_dir}/{swap_ext(files_in[0], '.d')}",
)

# The join() builtin here joins lists of strings with spaces so that lists of
# filenames, for example, can be plugged into a command.
rule_link = base_tut2.extend(
  desc      = "Link {files_in} -> {files_out}",
  command   = "g++ {join(files_in)} -o {files_out[0]}",
)

# Now we don't need files_out here, and we'll also automatically pick up the
# G++ dependency file generated by the -MMD option.
main_o = rule_compile(
  files_in = "src/main.cpp",
)

# Same here, Hancho will automatically look for util.d
util_o = rule_compile(
  files_in = "src/util.cpp"
)

# And we can pass both the compiled .o files to our linker
rule_link(
  files_in = [main_o, util_o],
  files_out = "app"
)
```

```shell
user@host:~/hancho/tutorial$ ./hancho.py tut2.hancho --verbose
[   1] Compile ['src/main.cpp'] -> ['build/tut2/src/main.o']
g++ -MMD -c src/main.cpp -o build/tut2/src/main.o
[   2] Link ['build/tut2/src/main.o'] -> ['build/tut2/app']
g++ build/tut2/src/main.o -o build/tut2/app
user@host:~/hancho/tutorial$ ./hancho.py tut2.hancho --verbose
hancho: no work to do.
user@host:~/hancho/tutorial$ touch src/main.hpp
user@host:~/hancho/tutorial$ ./hancho.py tut2.hancho --verbose
[   1] Compile ['src/main.cpp'] -> ['build/tut2/src/main.o']
g++ -MMD -c src/main.cpp -o build/tut2/src/main.o
[   2] Link ['build/tut2/src/main.o'] -> ['build/tut2/app']
g++ build/tut2/src/main.o -o build/tut2/app
```

Modifying a header file that's not mentioned in the .hancho file now causes a rebuild thanks to the depfile generated by GCC.

```
user@host:~/hancho/tutorial$ tree build
build
└── tut2
    ├── app
    └── src
        ├── main.d
        └── main.o

2 directories, 3 files
```

And the files are all under ```build/tut2``` as they should be.

---
### Tutorial 3 - Rule Files, Globs, and Helper Functions

We can move the boilerplate stuff that we'll be using in multiple builds into its own rules.hancho file for easier reuse:

```py
# tutorial/rules.hancho - Reusable rules for tutorial 3
import hancho

# We extend base_rule just like the previous example
base_tut3 = hancho.Rule(
  build_dir = "build/tut6"
)

# And these rules are the same as the previous example
rule_compile = base_tut3.extend(
  desc      = "Compile {files_in} -> {files_out}",
  command   = "g++ -c {files_in[0]} -o {files_out[0]}",
  files_out = "{swap_ext(files_in[0], '.o')}",
  depfile   = "{build_dir}/{swap_ext(files_in[0], '.d')}",
)

rule_link = base_tut3.extend(
  desc      = "Link {files_in} -> {files_out}",
  command   = "g++ {join(files_in)} -o {files_out[0]}",
)

# But since we're in Python, we can make helper functions to call rules for us
def compile(files):
  objs = []
  for file in files:
    objs.append(rule_compile(files_in = file))
  return objs

# And now compiling a bunch of files into a binary is just one call.
def c_binary(name, files):
  rule_link(
    files_in = compile(files),
    files_out = name
  )
```

And here's how we use rules.hancho:

```py
# tutorial/tut3.hancho - Rule Files, Globs, and Helper Functions
import hancho
import glob

# You can load additional Hancho build files as needed, though be sure to
# await them before using (darn asynchrony...)
rules = await hancho.load("rules.hancho")

# Since c_binary expects a list of filenames, we can use Python's built in
# glob functionality to compile all .cpp files in src/ into a binary.
rules.c_binary("app", glob.glob("src/*.cpp"))
```

---
### Tutorial 4 - Async/await and custom commands

Hancho loads .hancho files in an asynchronous context, which means it's perfectly valid (though perhaps not recommended) to do stuff like this:

```py
# tutorial/tut4.hancho -  Async/await and custom commands
import asyncio
import hancho
import os

# Calling asynchronous functions in a .hancho file is OK
async def do_slow_thing():
  await asyncio.sleep(1)
  return ["some_filename"]

hancho.log("Doing a slow asynchronous thing")
result = do_slow_thing()

# However, top-level awaits will block the rest of the build tasks in this file
hancho.log("Waiting on a slow asynchronous thing")
await result
hancho.log("Waiting done")
```

The "command" field in a Hancho rule can be an asynchronous callback instead of a command line. The callback should accept a fully-expanded Rule object as a parameter and should return a list of filenames generated by the command.

``` py
# Simple example of a custom command
async def custom_command(task):
  for f in task.files_out:
    hancho.log(f"Touching {f}")
    os.system(f"touch {f}")
  return task.files_out

custom_rule = hancho.Rule(
  desc    = "Custom rule: {files_in} -> {files_out}",
  command = custom_command
)

custom_result = custom_rule(
  files_in  = ["src/main.cpp"],
  files_out = ["build/tut4/custom1", "build/tut4/custom2"]
)

print(await custom_result)
```

Custom async/await stuff and custom rules should work:

```shell
user@host:~/hancho/tutorial$ ./hancho.py tut4.hancho
Doing a slow asynchronous thing
Waiting on a slow asynchronous thing
Waiting done
[   1] Custom rule: ['src/main.cpp'] -> ['build/tut4/custom1', 'build/tut4/custom2']
Touching build/tut4/custom1
Touching build/tut4/custom2
['/home/user/hancho/tutorial/build/tut4/custom1', '/home/user/hancho/tutorial/build/tut4/custom2']
```

But note that custom async/await bypasses all dependency checking, so running this build a second time will still call asyncio.sleep(1).

```shell
user@host:~/hancho/tutorial$ ./hancho.py tut4.hancho
Doing a slow asynchronous thing
Waiting on a slow asynchronous thing
Waiting done
['/home/user/hancho/tutorial/build/tut4/custom1', '/home/user/hancho/tutorial/build/tut4/custom2']
hancho: no work to do.
```


---
### Addendum - Debugging Hancho

The ```--debug``` flag will print very verbose internal info about the Hancho rules. The debug dumps are very verbose but should be sufficient to track down template problems and incorrect command lines.

The components of the debug output are:
 - "expand ..." messages for all templates
 - The description for each rule evaluated
 - The reason the rule was (or was not) executed
 - A JSON representation of the rule object
 - The command executed


```shell
user@host:~/hancho/tutorial$ ./hancho.py tut1.hancho --debug
expand "None"
expand ""
expand "src/main.cpp"
expand "build/tut1/src/main.o"
expand "g++ -c {files_in[0]} -o {files_out[0]}"
expand "g++ -c src/main.cpp -o build/tut1/src/main.o"
expand "Compile {files_in} -> {files_out}"
expand "Compile ['src/main.cpp'] -> ['build/tut1/src/main.o']"
[   1] Compile ['src/main.cpp'] -> ['build/tut1/src/main.o']
Rebuild reason: Rebuilding ['/home/user/hancho/tutorial/build/tut1/src/main.o'] because some are missing
{
  "files_in" : ["src/main.cpp"],
  "files_out" : ["build/tut1/src/main.o"],
  "base" : {
    "desc" : "Compile {files_in} -> {files_out}",
    "command" : "g++ -c {files_in[0]} -o {files_out[0]}",
    "base" : null,
  },
  "meta_deps" : [
    "/home/user/hancho/tutorial/tut1.hancho",
    "/home/user/hancho/tutorial/hancho.py",
  ],
  "deps" : [],
  "abs_files_in" : ["/home/user/hancho/tutorial/src/main.cpp"],
  "abs_files_out" : ["/home/user/hancho/tutorial/build/tut1/src/main.o"],
  "abs_deps" : [],
}
g++ -c src/main.cpp -o build/tut1/src/main.o
expand "None"
expand ""
Files ['/home/user/hancho/tutorial/build/tut1/src/main.o'] are up to date
expand "/home/user/hancho/tutorial/build/tut1/src/main.o"
expand "build/tut1/app"
expand "g++ {' '.join(files_in)} -o {files_out[0]}"
expand "g++ build/tut1/src/main.o -o build/tut1/app"
expand "Link {files_in} -> {files_out}"
expand "Link ['build/tut1/src/main.o'] -> ['build/tut1/app']"
[   2] Link ['build/tut1/src/main.o'] -> ['build/tut1/app']
Rebuild reason: Rebuilding ['/home/user/hancho/tutorial/build/tut1/app'] because some are missing
{
  "files_in" : ["build/tut1/src/main.o"],
  "files_out" : ["build/tut1/app"],
  "base" : {
    "desc" : "Link {files_in} -> {files_out}",
    "command" : "g++ {' '.join(files_in)} -o {files_out[0]}",
    "base" : null,
  },
  "meta_deps" : [
    "/home/user/hancho/tutorial/tut1.hancho",
    "/home/user/hancho/tutorial/hancho.py",
  ],
  "deps" : [],
  "abs_files_in" : ["/home/user/hancho/tutorial/build/tut1/src/main.o"],
  "abs_files_out" : ["/home/user/hancho/tutorial/build/tut1/app"],
  "abs_deps" : [],
}
g++ build/tut1/src/main.o -o build/tut1/app
Files ['/home/user/hancho/tutorial/build/tut1/app'] are up to date
```
