Tutorials:

----------
### Tutorial 0: Running Hancho

Hancho is distributed as a single Python file with no dependencies, just download it to your working directory:

``` bash
wget https://raw.githubusercontent.com/aappleby/hancho/main/hancho.py
chmod +x hancho.py
./hancho.py
```

Since we're already in the Hancho repo, [tutorial/hancho.py](tutorial/hancho.py) is just symlink'd to the copy in the repo root.

Let's start off by using Hancho to compile a trivial "Hello World" application:

``` cpp
// src/main.cpp

#include <stdio.h>

int main(int argc, char** argv) {
  printf("Hello World\n");
  return 0;
}
```

Hancho build files are just Python modules; our starting build file just hardcodes a build rule with a description and a command and then runs it:
``` py
# tutorial/tut0.hancho

import hancho

rule = hancho.Rule(
  desc = "Compile src/main.cpp",
  command = "g++ src/main.cpp",
)

rule()
```

You should now be able to compile src/main.cpp via ```./hancho.py tut0.hancho```.

```console
~/hancho/tutorial$ ./hancho.py tut0.hancho
[1/1] Compile src/main.cpp

~/hancho/tutorial$ ./a.out
Hello World
```

To see the commands as they're executed, use the ```--verbose``` flag:

```console
~/hancho/tutorial$ ./hancho.py tut0.hancho --verbose
[1/1] Compile src/main.cpp
g++ src/main.cpp
```

----------
### Tutorial 1: Compiling a C binary

Hardcoded build commands aren't terribly useful. Let's walk through tut1.hancho and see how we can make some reusable rules.

Strings in Hancho rules can contain templates - Python expressions contained in {} brackets. When the rule is evaluated, Hancho will replace the expressions in the templates with their evaluated values.


```py
# tutorial/tut1.hancho

import hancho

rule_compile = hancho.Rule(
  desc = "Compile {files_in} -> {files_out}",
  command = "g++ -c {files_in[0]} -o {files_out[0]}",
)
```

Some expressions have special meanings in Hancho - for example, "files_in" is always the list of files passed into a rule, and "files_out" is always the list of files generated by a rule.

Since templates can contain Python expressions, we can join a list of strings into a single string using ```' '.join(files_in)```

```py
rule_link = hancho.Rule(
  desc = "Link {files_in} -> {files_out}",
  command = "g++ {' '.join(files_in)} -o {files_out[0]}",
)
```

To use rules we call them as if they are functions. All the arguments to a rule must be named so that they can be used in templates. For convenience, if you pass a single string to files_in and files_out, Hancho will wrap them in a list:

```
rule_compile(
  files_in = "src/main.cpp",
  files_out = "build/src/main.o",
)

rule_link(
  files_in = "build/src/main.o",
  files_out = "build/app"
)
```


```console
~/hancho/tutorial$ ./hancho.py tut1.hancho --verbose
[1/2] Compile ['src/main.cpp'] -> ['build/main.o']
g++ -c src/main.cpp -o build/main.o
[2/2] Link ['build/main.o'] -> ['build/app']
g++ build/main.o -o build/app

~/hancho/tutorial$ ls build
app  main.o
```


----------
### Tutorial 2: Hancho builtins

In the previous example we hardcoded our output directory ```build/``` and the object filename ```build/src/main.o```. Let's make those more generic.

Hancho contains a small number of built-in functions to make common build tasks easier. These are contained in ```hancho.base_rule``` - a Rule object that we can extend with our own commands. Rule objects work much like Javascript objects - each rule can 'inherit' from another rule via Rule.extend(), and inside a template we can use both the parent's and the child's fields.

Rule fields can also be functions - in this example we're using ```base_rule.join()``` which is just shorthand for ```' '.join()```, and ```base_rule.swap_ext()``` which replaces the extension of a filename.

We'll also take advantage of the special rule field ```depfile```, which tells Hancho where to find a list of dependencies for the rule. The dependency file should be in [GCC format](http://find_a_gcc_format_reference). To make GCC generate a depfile when we compile source code, we pass it the ```-MMD``` option.

The ```hancho.base_rule``` also defines the special field ```build_dir```, which specifies where Hancho should place output files. Since we didn't override this, our outputs will go in ```build/``` by default.

Lastly, we'll make use of our rule's return value. Calling rule_compile() will return a list of the files generated by the rule, and we can then pass that list to rule_link instead of a hardcoded string.

```py
# tut2.hancho

import hancho

rule_compile = hancho.base_rule.extend(
  desc = "Compile {files_in[0]} -> {files_out[0]}",
  command = "g++ -MMD -c {files_in[0]} -o {files_out[0]}",
  files_out = "build/{swap_ext(files_in[0], '.o')}",
  depfile = "build/{swap_ext(files_in[0], '.d')}",
)

rule_link = hancho.base_rule.extend(
  desc = "Link {join(files_in)} -> {files_out[0]}",
  command = "g++ {join(files_in)} -o {files_out[0]}",
)

main_o = rule_compile(
  files_in = "src/main.cpp",
)

rule_link(
  files_in = main_o,
  files_out = "build/app"
)
```

```console
~/hancho/tutorial$ ./hancho.py tut2.hancho --verbose
[1/2] Compile ['src/main.cpp'] -> ['build/src/main.o']
g++ -c src/main.cpp -o build/src/main.o
[2/2] Link ['build/src/main.o'] -> ['build/app']
g++ build/src/main.o -o build/app

~/hancho/tutorial$ tree build
build
├── app
└── src
    └── main.o

1 directory, 2 files
```

Now that Hancho knows about all the dependencies of our build, running hancho.py a second time won't do anything as nothing needs to be rebuilt:

```console
~/hancho/tutorial$ ./hancho.py tut2.hancho --verbose
hancho: no work to do.
```

But if we modify src/main.hpp, it will rebuild src/main.cpp:

```console
~/hancho/tutorial$ touch src/main.hpp
~/hancho/tutorial$ hancho.py tut2.hancho --verbose
[1/2] Compile src/main.cpp -> build/src/main.o
g++ -MMD -c src/main.cpp -o build/src/main.o
[2/2] Link build/src/main.o -> build/app
g++ build/src/main.o -o build/app
```


-----
[tut3](tutorial/tut3.hancho): Using Hancho builtins

-----
[tut4](tutorial/tut4.hancho): Rule outputs

-----
[tut5](tutorial/tut5.hancho): Helper functions

-----
[tut6](tutorial/tut6.hancho): Loading .hancho files

-----
[tut7](tutorial/tut7.hancho): Debugging Hancho

The ```--debug``` flag will print very verbose internal info about the Hancho rules:

```console
~/hancho/tutorial$ ./hancho.py tut0.hancho --debug
expand "None"
expand ""
expand "Compile src/main.cpp"
[1/1] Compile src/main.cpp
Always rebuild a target with no outputs?
{
  "meta_deps" : ["/home/aappleby/repos/hancho/tutorial/tut0.hancho"],
  "base" : {
    "desc" : "Compile src/main.cpp",
    "command" : "g++ src/main.cpp",
    "base" : null,
  },
  "files_in" : [],
  "files_out" : [],
  "deps" : [],
  "abs_files_in" : [],
  "abs_files_out" : [],
  "abs_deps" : [],
}
expand "g++ src/main.cpp"
g++ src/main.cpp
```

The components of the debug output are:
 - "expand ..." messages for all text expansions (explained shortly)
 - The "[N/N] Description" for each rule evaluated
 - The reason the rule was (or was not) executed
 - A JSON representation of the rule object
 - The command executed
