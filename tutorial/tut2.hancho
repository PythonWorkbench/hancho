# tutorial/tut2.hancho - Extending base_rule & calling builtin functions
import hancho

# To make all rules in this tutorial use the same build directory, we'll first
# extend Hancho's built-in generic rule and specify build_dir.
hancho.config.set(build_dir = "build/tut2")

# We can then extend that to produce our compile and link rules.
# By using the swap_ext built-in, we can make our files_out and depfile
# parameters generic so we don't have to specify them for each invocation.
rule_compile = hancho.Rule(
  desc      = "Compile {files_in} -> {files_out}",
  command   = "g++ -MMD -c {files_in[0]} -o {files_out[0]}",
  files_out = "{swap_ext(files_in[0], '.o')}",
  depfile   = "{build_dir}/{swap_ext(files_in[0], '.d')}",
)

# The join() builtin here joins lists of strings with spaces so that lists of
# filenames, for example, can be plugged into a command.
rule_link = hancho.Rule(
  desc      = "Link {files_in} -> {files_out}",
  command   = "g++ {join(files_in)} -o {files_out[0]}",
)

# Now we don't need files_out here, and we'll also automatically pick up the
# G++ dependency file generated by the -MMD option.
main_o = rule_compile(
  files_in = "src/main.cpp",
)

# Same here, Hancho will automatically look for util.d
util_o = rule_compile(
  files_in = "src/util.cpp"
)

# And we can pass both the compiled .o files to our linker
rule_link(
  files_in = [main_o, util_o],
  files_out = "app"
)
